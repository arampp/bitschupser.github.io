#+TITLE: "First Look Into Azure Static Web Apps"
#+DATE: 2021-07-01T20:57:43+02:00
#+TAGS[]: azure
#+DRAFT: true

- Transfer an existing GitHub pages app to Azure devops
- Page will be built with hugo

* Initial Situation
  A while ago, I created a [[https://github.com/BitSchupser/bitschupser.github.io][static GitHub page]] serving a blog using the
  static web page generator [[https://gohugo.io/][HUGO]]. There was a GitHub action that
  triggered new build and deployed the site every time I pushed to the
  master branch.

  The aim of the task described here is to keep the repository but
  replace build, deployment and hosting by Azure Static Web Apps.

* Setup
** Preparations
     Before we can start, there need some preparations and cleanup work to be done:
   1. Delete existing GitHub pages build action, environment, deploy
      key and the gh-pages branch.
   2. Delete the existing GitHub actions yaml file.
   3. Create a new resource group in Azure portal.

** Create the Resource

   Creating the resource is straight forward. Choose "New Static Web
   App", give it a name and a region. Under deployment details, we have
   to connect the web app to our GitHub account and add the
   organization, repository and branch the web app should be built
   from.

   #+CAPTION: Setting up the Static Web App resource
   [[/images/github-to-static-webapps/create-resource.png]]

   Under "Build Details" we can configure how the app gets
   built. Luckily there is already a preset for HUGO, so we can build
   the site out of the box. There are also other build presets for:

   - Frameworks
     - Angular
     - React
     - Svelte
     - Vue.js
     - (client-side) Blazor
   - Static site generators
     - Gatsby
     - Hugo
     - VuePress

   For other technologies, we could choose "Custom" and configure the
   build as a step in GitHub actions.

   After creating the resource, the Static Web App automatically
   checks out the source code, builds it and deploys it. A few minutes
   later, the website can be visited under an auto-generated URL. Also
   a valid SSL certificate has been applied automatically.

** Add a custom domain
   This auto-generated URL is nice for testing but would be an
   imposition for any users. There is a menu entry called "custom
   domains" where a custom domain can be registered. After
   registration we copy and paste the provided CNAME entry the DNS
   record of our domain provider, wait a few minutes and the site is
   reachable through the custom domain.

   #+CAPTION: Add a custom domain to the site
   [[/images/github-to-static-webapps/add-custom-domain.png]]

* Workflows
** Modify the website
   If we want to modify the website, we just have to change some
   source code and push it to master. This will automatically trigger
   another build & deploy run. A few minutes later, the changes become
   visible on the website.

   But publishing a change without decent testing is quite
   dangerous. Usually we want to deploy the website into some staging
   environment, verify it and deploy it to production if the test
   passed. There is a mechanism that has a nice integration with
   GitHubs Pull Request mechanism.

** Pull Requests & Staging Environments
   Usually we develop on branches and create a pull request that gets
   reviewed by other developers prior to merging. We also want to do
   automatic & manual tests before merging.

   For this reason, Azure Static Web Apps hooks into the pull request
   mechanism and starts another job when a pull request has been
   created or updated:

   #+CAPTION: Azure Static Web Apps integration into pull requests
   [[/images/github-to-static-webapps/pr-build.png]]

   This job builds the application and deploys it to a staging
   environment. Staging environments have a -n attached to the
   subdomain, where n is the staging environment number. The free tier
   of Web Apps allows up to three staging environments.

   If a pull request has been merged, the staging environment gets
   removed automatically.

   #+CAPTION: Staging environment
   [[/images/github-to-static-webapps/staging-environment.png]]

   Too keep track of existing environments, there is the Environments
   menu entry in Azure portal:

   #+CAPTION: Environment
   [[/images/github-to-static-webapps/environments.png]]

* Looking under the hood
  All these automations out of the box are impressing, but how does it
  actually work?

** GitHub actions
  After creating the resource, Azure Static Web Apps deploys the
  following YAML file to the repo:

  #+BEGIN_SRC yaml
  name: Azure Static Web Apps CI/CD

on:
  push:
    branches:
      - master
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - master

jobs:
  build_and_deploy_job:
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')
    runs-on: ubuntu-latest
    name: Build and Deploy Job
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true
      - name: Build And Deploy
        id: builddeploy
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_POLITE_BEACH_075ECBD03 }}
          repo_token: ${{ secrets.GITHUB_TOKEN }} # Used for Github integrations (i.e. PR comments)
          action: "upload"
          ###### Repository/Build Configurations - These values can be configured to match your app requirements. ######
          # For more information regarding Static Web App workflow configurations, please visit: https://aka.ms/swaworkflowconfig
          app_location: "/src" # App source code path
          api_location: "" # Api source code path - optional
          output_location: "public" # Built app content directory - optional
          ###### End of Repository/Build Configurations ######

  close_pull_request_job:
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    runs-on: ubuntu-latest
    name: Close Pull Request Job
    steps:
      - name: Close Pull Request
        id: closepullrequest
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_POLITE_BEACH_075ECBD03 }}
          action: "close"
  #+END_SRC

  It defines two jobs: One gets triggered when a pull request will be
  created or updated, the other ones get triggered when a pull request
  got closed. At heart, they do both the same: calling another action
  called "Azure/static-web-apps-deploy@v1" with different parameters.

  To authenticate, it passes an API_TOKEN that also has been deployed
  to the GitHub repository when the resource has been created.

** Azure Static Web Apps Deploy Action
   Searching GitHub, we find a [[https://github.com/Azure/static-web-apps-deploy][repository]] containing the source code
   of the "Azure/static-web-apps-deploy@v1" action. This repository
   defines the action with all its parameters but calls at the bottom
   a binary called "StaticSitesClient" defined in the Docker image
   "mcr.microsoft.com/appsvc/staticappsclient"

   Unfortunately, [[https://github.com/Azure/static-web-apps/issues/306][this component isn't open source]], so we
   cannot dive into its details.

* Conclusion
  tbd
